import path from 'node:path';
import fs from 'fs-extra';
import pc from 'picocolors';
import Semver from 'semver';
import { cwd, getProjectPackageJson} from './workers';
import Logger from './utility/BuildLogger';
import Compiler, { BUNDLE_FILE_EXTENSION } from './plugin/Compiler';
import { Meteor } from 'meteor/meteor';
import { getBuildConfig, posixPath } from './utility/Helpers';
import { prepareViteBundle, ViteBundleOutput } from './plugin/IntermediaryMeteorProject';

const {
  meteorMainModule,
  isSimulatedProduction,
  viteOutSrcDir,
  pluginEnabled,
} = getBuildConfig();

// Empty stubs from any previous builds
if (pluginEnabled) {
  validateNpmDependencies();
  fs.ensureDirSync(viteOutSrcDir);
  fs.writeFileSync(path.join(path.dirname(viteOutSrcDir), '.gitignore'), '*');
  fs.writeFileSync(
      path.join(viteOutSrcDir, `meteor-entry.js.${BUNDLE_FILE_EXTENSION}`),
      `// Stub file for Meteor-Vite\n`, 'utf8'
  );
}

if (!pluginEnabled) {
  Logger.info('Build plugin is disabled')
}

// In development, clients will connect to the Vite development server directly. So there is no need for Meteor
// to do any work.
else if (process.env.NODE_ENV === 'production') {
  const bundle = build();
  
  try {
    // Meteor v3 build process (Async-await)
    if (Meteor.isFibersDisabled) {
      Plugin.registerCompiler({
        extensions: [BUNDLE_FILE_EXTENSION],
        filenames: [],
      }, () => bundle.then(() => new Compiler()));
      
      await bundle;
    }
    
    // Meteor v2 build process (Fibers)
    else {
      Promise.await(bundle);
      Plugin.registerCompiler({
        extensions: [BUNDLE_FILE_EXTENSION],
        filenames: [],
      }, () => new Compiler());
    }
    
    Logger.success('Build completed');
  } catch (error) {
    Logger.error(' Failed to complete build process:\n', error);
    throw error;
  }
}

async function build() {
  const { payload, entryAsset } = await prepareViteBundle();
  
  // Transpile and push the Vite bundle into the Meteor project's source directory
  transpileViteBundle({ payload });
  
  
  const importPath = path.relative(
      path.resolve(meteorMainModule, '..'),
      `${path.join(viteOutSrcDir, entryAsset.fileName)}.${BUNDLE_FILE_EXTENSION}`
  );
  const moduleImportPath = posixPath(`./${importPath}`);
  const meteorViteImport = `import ${JSON.stringify(moduleImportPath)};`
  const meteorViteImportTemplate = `
/**
 * This import is automatically generated by Meteor-Vite while building for production.
 * It should only point to your Vite production bundle, and is perfectly safe to remove or commit.
 *
 * If you're seeing this import including any other files like the Vite plugin itself,
 * Meteor might be trying to import ESM over CommonJS. Please open an issue if this happens.
 * Shouldn't be dangerous, but it might bloat your client bundle.
**/
${meteorViteImport}


`.trimLeft();
  
  Logger.debug('Injecting import for Vite bundle', { moduleImportPath, meteorMainModule, viteOutSrcDir });
  
  // Patch project's meteor entry with import for meteor-vite's entry module.
  // in node_modules/meteor-vite/temp
  const meteorEntry = path.join(cwd, meteorMainModule)
  const originalEntryContent = fs.readFileSync(meteorEntry, 'utf8');
  let originalEntryPatched = false;
  const oldEntryImports = [
      'meteor-vite/.build/import-vite-bundle.js',
      'meteor-vite/temp/stubs.js'
  ];
  
  // Patch import strings from older builds of the vite-bundler with an up-to-date import.
  for (const oldImport of oldEntryImports) {
    if (!originalEntryContent.includes(oldImport)) {
      continue;
    }
    const newContent = originalEntryContent.replace(oldImport, `${moduleImportPath}`);
    fs.writeFileSync(meteorEntry, newContent, 'utf8');
    originalEntryPatched = true;
  }
  
  // Import the Vite client bundle in the source project's client main module if it isn't already included.
  if (!originalEntryContent.includes(moduleImportPath) && !originalEntryPatched) {
    fs.writeFileSync(meteorEntry, `${meteorViteImportTemplate}\n${originalEntryContent}`, 'utf8')
  }
  
  Compiler.addCleanupHandler(() => {
    if (isSimulatedProduction) return;
    fs.removeSync(viteOutSrcDir);
    fs.writeFileSync(meteorEntry, originalEntryContent, 'utf8');
  });
}

function transpileViteBundle({ payload }: Pick<ViteBundleOutput, 'payload'>) {
  const profile = Logger.startProfiler();
  Logger.info('Transpiling Vite bundle for Meteor...');
  
  fs.ensureDirSync(viteOutSrcDir)
  fs.emptyDirSync(viteOutSrcDir)
  
  // Add .gitignore file to prevent the transpiled bundle from being committed accidentally.
  fs.writeFileSync(path.join(viteOutSrcDir, '.gitignore'), '/**');
  
  for (const { fileName: file } of payload.output) {
    const from = path.join(payload.outDir, file)
    const to = path.join(viteOutSrcDir, `${file}.${BUNDLE_FILE_EXTENSION}`);
    fs.ensureDirSync(path.dirname(to))
    
    if (path.extname(from) === '.js') {
      // Transpile to Meteor target (Dynamic import support)
      // @TODO don't use Babel
      const source = fs.readFileSync(from, 'utf8')
      const babelOptions = Babel.getDefaultOptions()
      babelOptions.babelrc = true
      babelOptions.sourceMaps = true
      babelOptions.filename = babelOptions.sourceFileName = from
      babelOptions.caller = babelOptions.caller || {
        name: 'meteor-vite',
        arch: 'web.browser.vite',
      }
      const transpiled = Babel.compile(source, babelOptions, {
        cacheDirectory: path.join(cwd, 'node_modules', '.babel-cache'),
      })
      fs.writeFileSync(to, transpiled.code, 'utf8')
    } else {
      fs.copyFileSync(from, to)
    }
  }
  
  profile.complete('Transpile completed');
}

function validateNpmDependencies() {
  const MIN_METEOR_VITE_NPM_VERSION = '1.12.1';
  const MIN_METEOR_VITE_NPM_VERSION_RANGE = `^${MIN_METEOR_VITE_NPM_VERSION}`;
  const packageJson = getProjectPackageJson();
  const packageLock = getProjectPackageJson('package-lock.json');
  const dependencies = packageLock.packages || packageLock.dependencies || {};
  
  // Check that the minimum compatible version of meteor-vite is installed.
  function meteorVite() {
    const version = dependencies['meteor-vite']?.version || dependencies['node_modules/meteor-vite']?.version;
    const minVersion = Semver.parse(MIN_METEOR_VITE_NPM_VERSION)
    
    if (!minVersion) {
      console.error(new Error('⚡  Unable to determine minimum required version of meteor-vite'));
      return;
    }
    
    const installCommand = pc.yellow(`${pc.dim('$')} meteor npm i meteor-vite@${minVersion.major}.${minVersion.minor}`);
    
    if (!version) {
      console.error([
        `⚡  Missing ${pc.cyan('meteor-vite')} in your dependencies!`,
        `   Please install it: ${installCommand}`,
      ].join('\n'))
      return;
    }
    
    if (Semver.satisfies(version, MIN_METEOR_VITE_NPM_VERSION_RANGE)) {
      return;
    }
    
    
    console.error([
      `⚡  You are using ${pc.cyan(`meteor-vite v${version}`)} which is not supported by the currently installed version of ${pc.cyan('jorgenvatle:vite-bundler')}`,
      `   Please update it: ${installCommand}`
    ].join('\n'))
  }
  
  // Warn users if `meteor-node-stubs` is missing from project dependencies
  function meteorNodeStubs() {
    if ('meteor-node-stubs' in packageJson.dependencies) {
      return;
    }
    
    console.warn([
      `⚡  Looks like ${pc.cyan('meteor-node-stubs')} is missing from your ${pc.italic('package.json')} dependencies`,
      `   Please install it: ` + pc.yellow(`${pc.dim('$')} meteor npm i meteor-node-stubs`),
    ].join('\n'));
  }
  
  function vite() {
    if (Meteor.isFibersDisabled === true) {
      // Meteor v3 should work with all Vite versions
      return;
    }
    
    const version = (dependencies['vite'] || dependencies['node_modules/vite'])?.version;
    const installCommand = pc.yellow(`${pc.dim('$')} meteor npm i vite@4`);
    if (!version) {
      console.warn([
        `⚡  Unable to determine currently installed ${pc.cyan('vite')} version`,
        `    Make sure to install it: ${installCommand}`
      ].join('\n'))
      return;
    }
    
    if (Semver.satisfies(version, '^4.0.0 || ^3.0.0')) {
      return;
    }
    
    console.warn([
      `⚡  You are using ${pc.cyan(`vite v${version}`)} which is not compatible with your current Meteor version`,
      `   Please install a compatible release: ${installCommand}`
    ].join('\n'))
  }
  
  vite();
  meteorVite();
  meteorNodeStubs();
}